name: Deploy BattleOne Infrastructure

on:
  push:
    branches: [main]
    paths:
      - '*.tf'
      - 'terraform.tfvars'
      - 'docker-compose.yml'
      - 'kratos/**'
      - 'cloud-init.yml'
      - '.github/workflows/terraform-deploy.yml'
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action to perform'
        required: true
        default: 'apply'
        type: choice
        options:
          - apply
          - plan
      auto_approve:
        description: 'Auto-approve the action (skip manual approval)'
        required: false
        default: false
        type: boolean

env:
  # DigitalOcean Configuration
  TF_VAR_digitalocean_token: ${{ secrets.DO_USER_ACCESS_TOKEN }}
  TF_VAR_spaces_access_key: ${{ secrets.DO_SPACES_ACCESS_KEY }}
  TF_VAR_spaces_secret_key: ${{ secrets.DO_SPACES_SECRET_KEY }}
  TF_VAR_ssh_private_key: ${{ secrets.DO_SSH_PRIVATE_KEY }}
  TF_VAR_ssh_public_key: ${{ secrets.DO_SSH_PUBLIC_KEY }}
  TF_VAR_laptop_ssh_public_key: ${{ secrets.DO_SSH_PUBLIC_KEY }}
  
  # Database Configuration
  TF_VAR_postgres_password: ${{ secrets.POSTGRES_PASSWORD }}
  TF_VAR_redis_password: ${{ secrets.REDIS_PASSWORD }}
  TF_VAR_postgres_db: ${{ secrets.POSTGRES_DB || 'battleone' }}
  TF_VAR_postgres_user: ${{ secrets.POSTGRES_USER || 'battleone_user' }}
  
  # Better Stack Configuration
  TF_VAR_betterstack_source_token: ${{ secrets.BETTERSTACK_SOURCE_TOKEN }}
  TF_VAR_betterstack_ingestion_host: ${{ secrets.BETTERSTACK_INGESTION_HOST || 'in.logs.betterstack.com' }}
  
  # Datadog Configuration (Deprecated - keeping for backward compatibility)
  TF_VAR_datadog_api_key: ${{ secrets.DATADOG_API_KEY || '' }}
  TF_VAR_datadog_site: ${{ secrets.DATADOG_SITE || 'datadoghq.com' }}
  
  # Infrastructure Settings
  TF_VAR_region: "tor1"
  TF_VAR_droplet_size: "s-1vcpu-512mb-10gb"
  
  # DigitalOcean Spaces for Terraform State
  AWS_ACCESS_KEY_ID: ${{ secrets.DO_SPACES_ACCESS_KEY }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.DO_SPACES_SECRET_KEY }}

jobs:
  terraform:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          echo "ðŸ” Validating required secrets..."
          
          # Check DigitalOcean secrets
          if [ -z "${{ secrets.DO_USER_ACCESS_TOKEN }}" ]; then
            echo "âŒ DO_USER_ACCESS_TOKEN secret is missing"
            exit 1
          fi
          
          # Check DigitalOcean Spaces secrets
          if [ -z "${{ secrets.DO_SPACES_ACCESS_KEY }}" ]; then
            echo "âŒ DO_SPACES_ACCESS_KEY secret is missing"
            exit 1
          fi
          if [ -z "${{ secrets.DO_SPACES_SECRET_KEY }}" ]; then
            echo "âŒ DO_SPACES_SECRET_KEY secret is missing"
            exit 1
          fi
          
          # Check SSH secrets
          if [ -z "${{ secrets.DO_SSH_PRIVATE_KEY }}" ]; then
            echo "âŒ DO_SSH_PRIVATE_KEY secret is missing"
            exit 1
          fi
          if [ -z "${{ secrets.DO_SSH_PUBLIC_KEY }}" ]; then
            echo "âŒ DO_SSH_PUBLIC_KEY secret is missing"
            exit 1
          fi
          
          # Check database secrets
          if [ -z "${{ secrets.POSTGRES_PASSWORD }}" ]; then
            echo "âŒ POSTGRES_PASSWORD secret is missing"
            exit 1
          fi
          if [ -z "${{ secrets.REDIS_PASSWORD }}" ]; then
            echo "âŒ REDIS_PASSWORD secret is missing"
            exit 1
          fi
          
          # Check Better Stack secrets
          if [ -z "${{ secrets.BETTERSTACK_SOURCE_TOKEN }}" ]; then
            echo "âŒ BETTERSTACK_SOURCE_TOKEN secret is missing"
            exit 1
          fi
          
          echo "âœ… All required secrets are configured"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.6"

      - name: Cache Terraform
        uses: actions/cache@v3
        with:
          path: |
            ~/.terraform.d/plugin-cache
            .terraform
          key: terraform-${{ hashFiles('**/.terraform.lock.hcl') }}
          restore-keys: terraform-

      - name: Terraform Init & Validate
        run: |
          echo "ðŸš€ Initializing and validating Terraform configuration..."
          terraform init
          terraform validate

      - name: Terraform Plan
        id: plan
        run: |
          echo "ðŸ“‹ Creating Terraform plan..."
          terraform plan -detailed-exitcode -out=tfplan
          echo "plan_exitcode=$?" >> $GITHUB_OUTPUT

      - name: Terraform Apply
        if: |
          (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
          (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        run: |
          echo "ðŸš€ Applying Terraform configuration..."
          terraform apply -auto-approve tfplan

      - name: Deploy Services with Docker Swarm
        if: |
          (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
          (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        run: |
          echo "ðŸ³ Deploying services to Docker Swarm..."
          
          # Get droplet IP from Terraform output
          DROPLET_IP=$(terraform output -raw droplet_ip)
          echo "Deploying to droplet: $DROPLET_IP"
          
          # Create temporary SSH key file
          echo "${{ secrets.DO_SSH_PRIVATE_KEY }}" > /tmp/ssh_key
          chmod 600 /tmp/ssh_key
          
          # Copy configuration files to droplet
          echo "ðŸ“‹ Uploading configuration files..."
          scp -i /tmp/ssh_key -o StrictHostKeyChecking=no -r \
            docker-compose.yml \
            kratos/ \
            postgres/ \
            vector/ \
            root@$DROPLET_IP:/opt/battleone/
          
          # Deploy stack via SSH with proper environment handling
          echo "ðŸš€ Deploying Docker stack..."
          ssh -i /tmp/ssh_key -o StrictHostKeyChecking=no root@$DROPLET_IP << 'EOF'
            set -e  # Exit on any error
            cd /opt/battleone
            
            # Ensure swarm is initialized
            docker swarm init --advertise-addr $(hostname -I | awk '{print $1}') 2>/dev/null || echo "Swarm already initialized"
            
            # Load and export environment variables for Docker Swarm
            echo "Loading environment variables for Docker Swarm deployment..."
            source .env
            export POSTGRES_USER
            export POSTGRES_PASSWORD  
            export POSTGRES_DB
            export REDIS_PASSWORD
            export BETTERSTACK_SOURCE_TOKEN
            export BETTERSTACK_INGESTION_HOST
            
            # Deploy the stack with exported environment variables
            echo "Deploying stack with exported environment variables..."
            if docker stack deploy -c docker-compose.yml battleone; then
              echo "âœ… Stack deployment command succeeded"
            else
              echo "âŒ Stack deployment command failed"
              exit 1
            fi
            
            # Wait for services to start
            echo "â³ Waiting for services to initialize..."
            sleep 60
            
            # Check service status and verify all services are running
            echo "ðŸ“Š Service status:"
            docker stack services battleone
            
            # Count running services vs expected
            RUNNING_SERVICES=$(docker stack services battleone --format "{{.Replicas}}" | grep -c "1/1" || true)
            TOTAL_SERVICES=$(docker stack services battleone --format "{{.Name}}" | wc -l)
            
            echo "Services running: $RUNNING_SERVICES/$TOTAL_SERVICES"
            
            if [ "$RUNNING_SERVICES" -lt "$TOTAL_SERVICES" ]; then
              echo "âš ï¸  Not all services are running yet, checking for errors..."
              
              # Show any service errors
              for service in $(docker stack services battleone --format "{{.Name}}"); do
                echo "--- $service logs ---"
                docker service logs "$service" --tail=10 2>/dev/null || echo "No logs available"
              done
              
              # Don't fail deployment if services are just starting up
              echo "â³ Services may still be starting up. Check status with: docker stack services battleone"
            else
              echo "âœ… All services are running successfully!"
            fi
          EOF
          
          # Cleanup
          rm /tmp/ssh_key
          echo "âœ… Docker Swarm deployment completed"

      - name: Deployment Summary & Health Check
        if: |
          (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
          (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        run: |
          echo "ðŸ¥ Performing infrastructure health check and generating summary..."
          
          # Get infrastructure details
          DROPLET_IP=$(terraform output -raw droplet_ip)
          KRATOS_URL=$(terraform output -raw kratos_internal_url)
          SSH_CONNECTION=$(terraform output -raw ssh_connection)
          
          echo "ðŸŒ Infrastructure deployed to: $DROPLET_IP"
          
          # Quick connectivity test (services are now managed by Docker Swarm)
          echo "â³ Waiting 30 seconds for final system checks..."
          sleep 30
          
          echo "ðŸ” Testing connectivity..."
          if ping -c 2 $DROPLET_IP > /dev/null 2>&1; then
            echo "âœ… Droplet is reachable"
            CONNECTIVITY_STATUS="âœ… Online"
          else
            echo "âš ï¸ Droplet connectivity issues (may still be initializing)"
            CONNECTIVITY_STATUS="âš ï¸ Initializing"
          fi
          
          # Generate deployment summary
          echo "## ðŸŽ‰ BattleOne Infrastructure Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Droplet IP**: $DROPLET_IP" >> $GITHUB_STEP_SUMMARY
          echo "- **Region**: Toronto (tor1)" >> $GITHUB_STEP_SUMMARY
          echo "- **Connectivity**: $CONNECTIVITY_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "- **Orchestration**: ðŸ³ Docker Swarm" >> $GITHUB_STEP_SUMMARY
          echo "- **PostgreSQL**: âœ… Deployed via Swarm" >> $GITHUB_STEP_SUMMARY
          echo "- **Redis**: âœ… Deployed via Swarm" >> $GITHUB_STEP_SUMMARY
          echo "- **Kratos**: âœ… Deployed via Swarm" >> $GITHUB_STEP_SUMMARY
          echo "- **Better Stack**: âœ… Monitoring via Swarm" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ”— **Access Information**:" >> $GITHUB_STEP_SUMMARY
          echo "- SSH: \`$SSH_CONNECTION\`" >> $GITHUB_STEP_SUMMARY
          echo "- Kratos: \`$KRATOS_URL\`" >> $GITHUB_STEP_SUMMARY
          echo "- Better Stack: [Dashboard](https://betterstack.com/logs)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ³ **Docker Swarm Commands**:" >> $GITHUB_STEP_SUMMARY
          echo "- Check services: \`docker stack services battleone\`" >> $GITHUB_STEP_SUMMARY
          echo "- View logs: \`docker service logs battleone_postgres\`" >> $GITHUB_STEP_SUMMARY
          echo "- Update stack: \`docker stack deploy -c docker-compose.yml battleone\`" >> $GITHUB_STEP_SUMMARY

      - name: Notify deployment completion
        if: success()
        run: |
          echo "ðŸŽ‰ BattleOne infrastructure deployment completed successfully!"
          echo "ðŸ”— Infrastructure is ready at: $(terraform output -raw droplet_ip)"